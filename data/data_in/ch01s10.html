<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Popular productivity tools</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
</head>
<body id="page">
<div class="section" title="Popular productivity tools">
    <div class="titlepage">
        <div>
            <div><h1 class="title">Popular productivity tools</h1></div>
        </div>
    </div>
    <p>A productivity tool is a bit of a vague term. On one hand, almost every open source code package released and
        available online is a kind of productivity booster—it provides ready-to-use solutions to some problem, so no one
        needs to spend time on it (ideally speaking). On the other hand, one could say that the whole of Python is about
        productivity. And both are undoubtedly true. Almost everything in this language and community surrounding it
        seems to be designed in order to make software development as productive as it is possible.</p>
    <p>This creates a positive feedback loop. Since writing code is fun and easy, a lot of programmers spend their free
        time to create tools that make it even easier and fun. And this fact will be used here as a basis for a very
        subjective and non-scientific definition of a productivity tool—a piece of software that makes development
        easier and more fun.</p>
    <p>By nature, productivity tools focus mainly on certain elements of the development process such as testing,
        debugging, and managing packages and are not core parts of products that they help to build. In some cases, they
        may not even be referred to anywhere in the project's codebase despite being used on a daily basis.</p>
    <p>The most important productivity tools, <code class="literal">pip</code> and <code class="literal">venv</code>,
        were already discussed earlier in this chapter. Some of them have packages for specific problems, such as
        profiling and testing, and have their own chapters in the book. This section is dedicated to other tools that
        are really worth mentioning, but have no specific chapter in the book where they could be introduced.</p>
    <div class="section" title="Custom Python shells – IPython, bpython, ptpython, and so on">
        <div class="titlepage">
            <div>
                <div><h2 class="title">Custom Python shells – IPython, bpython, ptpython, and so on</h2></div>
            </div>
        </div>
        <p>Python programmers spend a lot of time in interactive interpreter sessions. It is very good for testing small
            code snippets, accessing documentation, or even debugging code at run time. The default interactive Python
            session is very simple and does not provide many features such as tab completion or code introspection
            helpers. Fortunately, the default Python shell can be easily extended and customized.</p>
        <p>The interactive prompt can be configured with a startup file. When it starts, it looks for the <code
                class="literal">PYTHONSTARTUP</code> environment variable and executes the code in the file pointed to
            by this variable. Some Linux distributions provide a default startup script, which is generally located in
            your home directory. It is called <code class="literal">.pythonstartup</code>. Tab completion and command
            history are often provided to enhance the prompt and are based on the <code class="literal">readline</code>
            module. (You need the <code class="literal">readline</code> library.)</p>
        <p>If you don't have such a file, you can easily create one. Here's an example of the simplest startup file that
            adds completion with the <code class="literal">&lt;Tab&gt;</code> key and history:</p>
        <div class="informalexample"><pre class="programlisting"># python startup file
import readline
import rlcompleter
import atexit
import os

# tab completion
readline.parse_and_bind('tab: complete')

# history file
histfile = os.path.join(os.environ['HOME'], '.pythonhistory')
try:
    readline.read_history_file(histfile)

except IOError:
    pass

atexit.register(readline.write_history_file, histfile)
del os, histfile, readline, rlcompleter</pre>
        </div>
        <p>Create this file in your home directory and call it <code class="literal">.pythonstartup</code>. Then, add a
            <code class="literal">PYTHONSTARTUP</code> variable in your environment using the path of your file:</p>
        <div class="section" title="Setting up the PYTHONSTARTUP environment variable">
            <div class="titlepage">
                <div>
                    <div><h3 class="title">Setting up the PYTHONSTARTUP environment variable</h3></div>
                </div>
            </div>
            <p>If you are running Linux or Mac OS X, the simplest way is to create the startup script in your home
                folder. Then, link it with a <code class="literal">PYTHONSTARTUP</code> environment variable set into
                the system shell startup script. For example, the Bash and Korn shells use the <code class="literal">.profile</code>
                file, where you can insert a line as follows:</p>
            <div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>export PYTHONSTARTUP=~/.pythonstartup</strong></span>
</pre>
            </div>
            <p>If you are running Windows, it is easy to set a new environment variable as an administrator in the
                system preferences, and save the script in a common place instead of using a specific user location.</p>
            <p>Writing on the <code class="literal">PYTHONSTARTUP</code> script may be a good exercise but creating good
                custom shell all alone is a challenge that only few can find time for. Fortunately, there are a few
                custom Python shell implementations that immensely improve the experience of interactive sessions in
                Python.</p></div>
        <div class="section" title="IPython">
            <div class="titlepage">
                <div>
                    <div><h3 class="title">IPython</h3></div>
                </div>
            </div>
            <p>IPyhton (<a class="ulink" href="http://ipython.scipy.org">http://ipython.scipy.org</a>) provides an
                extended Python command shell. Among the features provided, the most interesting ones are:</p>
            <div class="itemizedlist">
                <ul class="itemizedlist">
                    <li class="listitem" style="list-style-type: disc">Dynamic object introspection</li>
                    <li class="listitem" style="list-style-type: disc">System shell access from the prompt</li>
                    <li class="listitem" style="list-style-type: disc">Profiling direct support</li>
                    <li class="listitem" style="list-style-type: disc">Debugging facilities</li>
                </ul>
            </div>
            <p>Now, IPython is a part of the larger project called Jupyter that provides interactive notebooks with live
                code that can be written in many different languages.</p></div>
        <div class="section" title="bpython">
            <div class="titlepage">
                <div>
                    <div><h3 class="title">bpython</h3></div>
                </div>
            </div>
            <p>bpython (<a class="ulink" href="http://bpython-interpreter.org/">http://bpython-interpreter.org/</a>)
                advertises itself as a fancy interface to the python interpreter. Here are some of the accented on the
                projects page:</p>
            <div class="itemizedlist">
                <ul class="itemizedlist">
                    <li class="listitem" style="list-style-type: disc">In-line syntax highlighting</li>
                    <li class="listitem" style="list-style-type: disc">Readline-like autocomplete with suggestions
                        displayed as you type
                    </li>
                    <li class="listitem" style="list-style-type: disc">Expected parameter lists for any Python
                        function
                    </li>
                    <li class="listitem" style="list-style-type: disc">Autoindentation</li>
                    <li class="listitem" style="list-style-type: disc">Python 3 support</li>
                </ul>
            </div>
        </div>
        <div class="section" title="ptpython">
            <div class="titlepage">
                <div>
                    <div><h3 class="title">ptpython</h3></div>
                </div>
            </div>
            <p>ptpython (<a class="ulink" href="https://github.com/jonathanslenders/ptpython/">https://github.com/jonathanslenders/ptpython/</a>)
                is another approach to the topic of advanced Python shells. In this project, core prompt utilities
                implementation is available as a separate package called <code class="literal">prompt_toolkit</code>
                (from the same author). This allows you to easily create various aesthetically pleasing interactive
                command-line interfaces.</p>
            <p>It is often compared to bpython in functionalities but the main difference is that it enables a
                compatibility mode with IPython and its syntax that enables additional features such as <code
                        class="literal">%pdb</code>, <code class="literal">%cpaste</code>, or <code class="literal">%profile</code>.
            </p></div>
    </div>
    <div class="section" title="Interactive debuggers">
        <div class="titlepage">
            <div>
                <div><h2 class="title">Interactive debuggers</h2></div>
            </div>
        </div>
        <p>Code debugging is an integral element of the software development process. Many programmers can spend most of
            their life using only extensive logging and <code class="literal">print</code> statements as their primary
            debugging tools but most professional developers prefer to rely on some kind of debugger.</p>
        <p>Python already ships with a built-in interactive debugger called <code class="literal">pdb</code> (refer to
            <a class="ulink" href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>).
            It can be invoked from the command line on the existing script, so Python will enter post-mortem debugging
            if the program exits abnormally:</p>
        <div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -m pdb script.py</strong></span>
</pre>
        </div>
        <p>Post-mortem debugging, while useful, does not cover every scenario. It is useful only when the application
            exists with some exception if the bug occurs. In many cases, faulty code just behaves abnormally but does
            not exit unexpectedly. In such cases, custom breakpoints can be set on a specific line of code using this
            single-line idiom:</p>
        <div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import pdb; pdb.set_trace()</strong></span>
</pre>
        </div>
        <p>This will cause the Python interpreter to start the debugger session on this line during run time.</p>
        <p><code class="literal">pdb</code> is very useful for tracing issues and at first glance, it may look very
            familiar to the well-known GDB (GNU Debugger). Because Python is a dynamic language, the <code
                    class="literal">pdb</code> session is very similar to an ordinary interpreter session. This means
            that the developer is not limited to tracing code execution but can call any code and even perform module
            imports.</p>
        <p>Sadly, because of its roots (<code class="literal">bdb</code>), the first experience with <code
                class="literal">pdb</code> can be a bit overwhelming due to the existence of cryptic short letter
            debugger commands such as <code class="literal">h</code>, <code class="literal">b</code>, <code
                    class="literal">s</code>, <code class="literal">n</code>, <code class="literal">j</code>, and <code
                    class="literal">r</code>. Whenever in doubt, the <code class="literal">help pdb</code> command typed
            during the debugger session will provide extensive usage and additional information.</p>
        <p>The debugger session in pdb is also very simple and does not provide additional features like tab completion
            or code highlighting. Fortunately, there are few packages available on PyPI that provide such features
            available from alternative Python shells mentioned in the previous section. The most notable examples
            are:</p>
        <div class="itemizedlist">
            <ul class="itemizedlist">
                <li class="listitem" style="list-style-type: disc"><code class="literal">ipdb</code>: This is a separate
                    package based on <code class="literal">ipython</code></li>
                <li class="listitem" style="list-style-type: disc"><code class="literal">ptpdb</code>: This is a
                    separate package based on <code class="literal">ptpython</code></li>
                <li class="listitem" style="list-style-type: disc"><code class="literal">bpdb</code>: This is bundled
                    with <code class="literal">bpython</code></li>
            </ul>
        </div>
    </div>
</div>
</body>
</html>
