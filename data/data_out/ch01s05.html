<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Основные различия между Python 3 и Python 2</title>
<link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
</head>
<body id="page">
<div class="section" title="Основные различия между Python 3 и Python 2">
<div class="titlepage">
<div>
<div><h1 class="title">Основные различия между Python 3 и Python 2</h1></div>
</div>
</div>
<p>Уже было сказано, что Python 3 нарушает обратную совместимость с Python 2. Тем не менее, это не полная переработка. Кроме того, это не означает, что каждый модуль Python, написанный для версии 2.x, перестанет работать под Python 3. Можно написать полностью кросс-совместимый код, который будет работать в обоих основных выпусках без дополнительных инструментов или методов, но обычно это возможно только для простых приложений.</p>
<div class="section" title="Почему это должно меня волновать?">
<div class="titlepage">
<div>
<div><h2 class="title">Почему это должно меня волновать?</h2></div>
</div>
</div>
<p>Несмотря на мое личное мнение о совместимости с Python 2, изложенное ранее в этой главе, сейчас невозможно просто забыть об этом. Есть еще несколько полезных пакетов (например, ткани, упомянутые в <a class="link" href="ch06.html" title="Глава 6. Развертывание кода">главе 6</a> , <span class="emphasis"><em>развертывание Кодекса</em></span> ), которые на самом деле стоит использовать , но которые , вероятно, не будут перенесены в самое ближайшее время.</p>
<p>Кроме того, иногда нас может ограничивать организация, в которой мы работаем. Существующий унаследованный код может быть настолько сложным, что переносить его экономически нецелесообразно. Таким образом, даже если мы решим двигаться дальше и жить только в мире Python 3 с этого момента, какое-то время будет невозможно полностью жить без Python 2.</p>
<p>В настоящее время очень сложно назвать себя профессиональным разработчиком, не отдавая что-то сообществу, поэтому помощь разработчикам с открытым исходным кодом в добавлении совместимости с Python 3 к существующим пакетам - хороший способ выплатить «моральный долг», понесенный за счет использования их. Это, конечно, невозможно сделать, не зная различий между Python 2 и Python 3. Кстати, это также отличное упражнение для новичков в Python 3.</p></div>
<div class="section" title="Основные синтаксические различия и распространенные ошибки">
<div class="titlepage">
<div>
<div><h2 class="title">Основные синтаксические различия и распространенные ошибки</h2></div>
</div>
</div>
<p>Документация Python - лучший справочник различий между каждым выпуском. Во всяком случае, для удобства читателей в этом разделе собраны самые важные из них. Это не меняет того факта, что документация является обязательной для чтения для тех, кто еще не знаком с Python 3 (см. <a class="ulink" href="https://docs.python.org/3.0/whatsnew/3.0.html">Https://docs.python.org/3.0/whatsnew/3.0.html</a> ).
        </p>
<p>Критические изменения, внесенные Python 3, обычно можно разделить на несколько групп:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">Изменения синтаксиса, при этом некоторые элементы синтаксиса были удалены / изменены, а другие элементы были добавлены
                </li>
<li class="listitem" style="list-style-type: disc">Изменения в стандартной библиотеке</li>
<li class="listitem" style="list-style-type: disc">Изменения в типах данных и коллекциях</li>
</ul>
</div>
<div class="section" title="Изменения синтаксиса">
<div class="titlepage">
<div>
<div><h3 class="title">Изменения синтаксиса</h3></div>
</div>
</div>
<p>Изменения синтаксиса, которые затрудняют выполнение существующего кода, легче всего обнаружить - они приведут к тому, что код вообще не будет выполняться. Код Python 3 с новыми элементами синтаксиса не сможет работать на Python 2 и наоборот. Удаленные элементы сделают код Python 2 явно несовместимым с Python 3. Выполняющийся код, который имеет такие проблемы, немедленно приведет к тому, что интерпретатор не сработает при создании <code class="literal">SyntaxError</code>исключения. Вот пример неработающего скрипта, который имеет ровно два оператора, из которых ни один не будет выполнен из-за синтаксической ошибки:</p>
<div class="informalexample"><pre class="programlisting">print("hello world")
print "goodbye python2"</pre>
</div>
<p>Его фактический результат при запуске на Python 3 выглядит следующим образом:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ python3 script.py</strong></span>
<span class="strong"><strong>  File "script.py", line 2</strong></span>
<span class="strong"><strong>    print "goodbye python2"</strong></span>
<span class="strong"><strong>                         ^</strong></span>
<span class="strong"><strong>SyntaxError: Missing parentheses in call to 'print'</strong></span>
</pre>
</div>
<p>Список таких различий немного длинный, и время от времени в любой новый выпуск Python 3.x могут добавляться новые элементы синтаксиса, которые будут вызывать такие ошибки в более ранних выпусках Python (даже в той же ветке 3.x). Наиболее важные из них описаны в <a class="link" href="ch02.html" title="Глава 2. Рекомендации по синтаксису - ниже уровня класса">главе 2</a> , <span class="emphasis"><em>Синтаксис Best Practices - ниже уровня класса</em></span> , и <a class="link" href="ch03.html" title="Глава 3. Рекомендации по синтаксису - выше уровня класса">главы 3</a> , <span class="emphasis"><em>синтаксис Best Practices - выше уровня класса</em></span> , поэтому нет необходимости перечислять их все здесь.</p>
<p>Список вещей, которые были удалены или изменены в Python 2.7, короче, поэтому вот самые важные из них:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc"><code class="literal">print</code> больше не оператор, а функция, поэтому скобки теперь обязательны.
                    </li>
<li class="listitem" style="list-style-type: disc">Перехват исключений изменен с <code class="literal">except exc, var</code>на <code class="literal">except exc as var</code>.
                    </li>
<li class="listitem" style="list-style-type: disc">Оператор <code class="literal">&lt;&gt;</code>
                        сравнения был удален в пользу <code class="literal">!=</code>.
                    </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">from module import *</code>
                        ( <a class="ulink" href="https://docs.python.org/3.0/reference/simple_stmts.html#import">https://docs.python.org/3.0/reference/simple_stmts.html#import</a> ) теперь разрешено только на уровне модуля, а не внутри функций.
                    </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">from .[module] import
                        name</code>теперь единственный принятый синтаксис для относительного импорта. Все операции импорта, не начинающиеся с точки, интерпретируются как абсолютные.
                    </li>
<li class="listitem" style="list-style-type: disc">Не <code class="literal">sort()</code>функция и в списке в <code class="literal">sorted()</code>метод больше не принимать <code class="literal">cmp</code>аргумент. <code class="literal">key</code>Аргумент должен быть использован вместо.
                    </li>
<li class="listitem" style="list-style-type: disc">Выражения деления для целых чисел, такие как 1/2, возвращают числа с плавающей запятой. Усечение достигается с помощью <code class="literal">//</code>
                        оператора like <code class="literal">1//2</code>. Хорошо то, что это можно использовать и с поплавками, так что <code class="literal">5.0//2.0 == 2.0</code>.
                    </li>
</ul>
</div>
</div>
<div class="section" title="Изменения в стандартной библиотеке">
<div class="titlepage">
<div>
<div><h3 class="title">Изменения в стандартной библиотеке</h3></div>
</div>
</div>
<p>Критические изменения в стандартной библиотеке - второе, что легче всего обнаружить после изменений синтаксиса. Каждая последующая версия Python добавляет, отменяет, улучшает или полностью удаляет стандартные библиотечные модули. Такой процесс был регулярным и в более старых версиях Python (1.x и 2.x), поэтому он не стал шоком для Python 3. В большинстве случаев, в зависимости от модуля, который был удален или реорганизован (например <code class="literal">urlparse</code>, переехал в<code class="literal">urllib.parse</code>), он вызовет исключения во время импорта сразу после его интерпретации. Это позволяет легко обнаружить такие проблемы. В любом случае, чтобы быть уверенным, что все такие проблемы решены, необходимо полное покрытие тестового кода. В некоторых случаях (например, при использовании лениво загружаемых модулей) проблемы, которые обычно замечаются во время импорта, не появятся до того, как некоторые модули будут использованы в коде как вызовы функций. Вот почему так важно убедиться, что каждая строка кода действительно выполняется во время набора тестов.
            </p>
<div class="note" style="" title="Примечание">
<div class="inner"><h3 class="title">Кончик</h3>
<p><span class="strong"><strong>Лениво загружаемые модули</strong></span></p>
<p>Лениво загруженный модуль - это модуль, который не загружается во время импорта. В Python <code class="literal">import</code>операторы могут быть включены в функции, поэтому импорт будет происходить при вызове функции, а не во время импорта. В некоторых случаях такая загрузка модулей может быть разумным выбором, но в большинстве случаев это обходной путь для плохо спроектированных структур модулей (например, во избежание циклического импорта), и его обычно следует избегать. Конечно, нет никаких уважительных причин для ленивой загрузки стандартных библиотечных модулей.</p></div>
</div>
</div>
<div class="section" title="Изменения в типах данных и коллекциях">
<div class="titlepage">
<div>
<div><h3 class="title">Изменения в типах данных и коллекциях</h3></div>
</div>
</div>
<p>Изменения в том, как Python представляет типы данных и коллекции, требуют наибольших усилий, когда разработчик пытается поддерживать совместимость или просто переносить существующий код на Python 3. Хотя несовместимый синтаксис или изменения стандартной библиотеки легко заметны и их легче всего исправить, изменения в коллекциях и типах либо неочевидны, либо требуют много повторяющейся работы. Список таких изменений длинный, и, опять же, официальная документация - лучший справочник.</p>
<p>Тем не менее, этот раздел должен охватывать изменение того, как строковые литералы обрабатываются в Python 3, потому что это кажется наиболее спорным и обсуждаемым изменением в Python 3, несмотря на то, что это очень хорошая вещь, которая теперь делает вещи более явными.</p>
<p>Все строковые литералы теперь являются Unicode, а для <code class="literal">bytes</code>литералов требуется префикс <code class="literal">b</code>или <code class="literal">B</code>. Для Python 3.0 и 3.1 использование
                 <code class="literal">u</code>префикса (например, <code class="literal">u"foo"</code>) было удалено и вызовет синтаксическую ошибку. Отказ от этой приставки был главной причиной всех разногласий. Было действительно сложно создать код, совместимый с различными ветвями Python - версия 2.x полагалась на этот префикс для создания литералов Unicode. Этот префикс был возвращен в Python 3.3 для облегчения процесса интеграции, хотя и без синтаксического значения.</p></div>
</div>
<div class="section" title="Популярные инструменты и методы, используемые для поддержки кросс-версии совместимости">
<div class="titlepage">
<div>
<div><h2 class="title">Популярные инструменты и методы, используемые для поддержки кросс-версии совместимости</h2></div>
</div>
</div>
<p>Поддержание совместимости между версиями Python - непростая задача. Это может добавить много дополнительной работы в зависимости от размера проекта, но определенно выполнимо и того стоит. Для пакетов, которые предназначены для повторного использования во многих средах, это абсолютно необходимо. Пакеты с открытым исходным кодом без четко определенных и проверенных границ совместимости вряд ли станут популярными, но закрытый сторонний код, который никогда не покидает сеть компании, может получить большую выгоду от тестирования в различных средах.</p>
<p>Здесь следует отметить, что, хотя в этой части основное внимание уделяется совместимости между различными версиями Python, эти подходы применяются для поддержания совместимости с внешними зависимостями, такими как разные версии пакетов, двоичные библиотеки, системы или внешние службы.</p>
<p>Весь процесс можно разделить на три основные области, упорядоченные по важности:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">Определение и документирование целевых границ совместимости и способов управления ими
                </li>
<li class="listitem" style="list-style-type: disc">Тестирование в любой среде и с каждой версией зависимости, объявленной как совместимой.
                </li>
<li class="listitem" style="list-style-type: disc">Реализация актуального кода совместимости</li>
</ul>
</div>
<p>Объявление того, что считается совместимым, является наиболее важной частью всего процесса, потому что оно дает пользователям кода (разработчикам) возможность иметь ожидания и делать предположения о том, как он работает и как он может измениться в будущем. Наш код можно использовать в качестве зависимости в различных проектах, которые также могут стремиться к управлению совместимостью, поэтому возможность рассуждать о его поведении имеет решающее значение.</p>
<p>Хотя в этой книге всегда делается попытка предложить несколько вариантов, а не дать абсолютные рекомендации по конкретным вариантам, вот одно из немногих исключений. На данный момент лучший способ определить, как совместимость может измениться в будущем, - это правильный подход к номерам версий с использованием <span class="emphasis"><em>семантического управления версиями</em></span> 
            ( <a class="ulink" href="http://semver.org/">http://semver.org/</a> ) или, вкратце, semver. Он описывает широко принятый стандарт для обозначения объема изменений в коде с помощью спецификатора версии, состоящего только из трех цифр. Он также дает несколько советов о том, как обращаться с политиками устаревания. Вот выдержка из его резюме:</p>
<p>Учитывая номер версии <code class="literal">MAJOR.MINOR.PATCH</code>, приращение:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc"><code class="literal">MAJOR</code>Версия при внесении несовместимых изменений API
                </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">MINOR</code>Версии при добавлении функциональности в обратной совместимости способа
                </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">PATCH</code>Версия , когда вы делаете обратную совместимость исправления ошибок
                </li>
</ul>
</div>
<p>Дополнительные метки для метаданных предварительной версии и сборки доступны как расширения <code class="literal">MAJOR.MINOR.PATCH</code>формата.</p>
<p>Когда дело доходит до тестирования, печальная правда заключается в том, что чтобы убедиться, что код совместим с каждой объявленной версией зависимостей и в любой среде (здесь версия Python), он должен быть протестирован в каждой их комбинации. Это, конечно, может быть невозможно, когда в проекте много зависимостей, потому что количество комбинаций быстро растет с каждой новой зависимостью в версии. Таким образом, обычно требуется некоторый компромисс, чтобы выполнение тестов на полную совместимость не заняло много времени. Выбор инструментов , которые помогают тестированию в так называемых матрицах представлено в <a class="link" href="ch10.html" title="Глава 10. Разработка через тестирование">главе 10</a> , <span class="emphasis"><em>Test-Driven Development</em></span> , которая обсуждается тестирование в целом.</p>
<div class="note" style="" title="Примечание">
<div class="inner"><h3 class="title">Примечание</h3>
<p>Преимущество использования проектов, следующих за semver, заключается в том, что обычно нужно тестировать только основные выпуски, потому что второстепенные выпуски и выпуски исправлений гарантированно не включают обратно несовместимых изменений. Это верно только в том случае, если таким проектам можно доверять, что они не нарушат такой контракт. К сожалению, ошибки случаются со всеми, и обратно несовместимые изменения происходят во многих проектах, даже в версиях исправлений. Тем не менее, поскольку semver декларирует строгую совместимость при незначительных изменениях версии и версии патча, ее нарушение считается ошибкой и может быть исправлено в выпуске патча.</p>
</div>
</div>
<p>Реализация уровня совместимости является последней и наименее важной, если границы этой совместимости четко определены и тщательно протестированы. Тем не менее, есть некоторые инструменты и методы, которые должен знать каждый программист, интересующийся такой темой.</p>
<p>Самый простой - это <code class="literal">__future__</code>модуль Python . Он переносит некоторые функции из новых версий Python обратно в старые версии и принимает форму оператора импорта:</p>
<div class="informalexample">
<pre class="programlisting">from __future__ import &lt;feature&gt;</pre>
</div>
<p>Возможности, предоставляемые <code class="literal">future</code>операторами, являются элементами, связанными с синтаксисом, которые не могут быть легко обработаны другими способами. Этот оператор влияет только на модуль, в котором он использовался. Вот пример интерактивного сеанса Python 2.7, который переносит литералы Unicode из Python 3.0:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Python 2.7.10 (default, May 23 2015, 09:40:32) [MSC v.1500 32 bit (Intel)] on win32</strong></span>
<span class="strong"><strong>Type "help", "copyright", "credits" or "license" for more information.</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type("foo")  # old literals</strong></span>
<span class="strong"><strong>&lt;type 'str'&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from __future__ import unicode_literals</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type("foo")  # now is unicode</strong></span>
<span class="strong"><strong>&lt;type 'unicode'&gt;</strong></span>
</pre>
</div>
<p>Вот список всех доступных <code class="literal">__future__</code>опций операторов, которые должны знать разработчики, заинтересованные в совместимости 2/3:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc"><code class="literal">division</code>: Это добавляет оператор деления Python 3 (PEP 238)
                </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">absolute_import</code>: Это заставляет каждую форму <code class="literal">import</code>оператора, не начинающуюся с точки, интерпретировать как абсолютный импорт (PEP 328)
                </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">print_function</code>: Это превращает <code class="literal">print</code>оператор в вызов функции, поэтому скобки вокруг
                     <code class="literal">print</code>становятся обязательными (PEP 3112)
                </li>
<li class="listitem" style="list-style-type: disc"><code class="literal">unicode_literals</code>: Это заставляет каждый строковый литерал интерпретироваться как литералы Unicode (PEP 3112)
                </li>
</ul>
</div>
<p>Список <code class="literal">__future__</code>опций оператора очень короткий и охватывает лишь некоторые особенности синтаксиса. Другие вещи, которые изменились, такие как синтаксис метакласса (который представляет собой расширенную функцию, описанную в <a class="link" href="ch03.html" title="Глава 3. Рекомендации по синтаксису - выше уровня класса">главе 3</a> , <span class="emphasis"><em>Рекомендации по синтаксису - выше уровня класса</em></span> ), намного сложнее поддерживать. Надежная обработка множественных реорганизаций стандартной библиотеки также не может быть решена с помощью <code class="literal">future</code>операторов. К счастью, есть некоторые инструменты, которые стремятся обеспечить согласованный уровень готовой к использованию совместимости. Наиболее широко известен Six ( <a class="ulink" href="https://pypi.python.org/pypi/six/">https://pypi.python.org/pypi/six/</a>), который обеспечивает общий стандартный шаблон совместимости 2/3 в виде единого модуля. Другой многообещающий, но немного менее популярный инструмент - это модуль future ( <a class="ulink" href="http://python-future.org/">http://python-future.org/</a> ).
        </p>
<p>В некоторых ситуациях разработчики могут не захотеть включать дополнительные зависимости в некоторые небольшие пакеты. Обычной практикой является дополнительный модуль, который собирает весь код совместимости, обычно называемый <code class="literal">compat.py</code>. Вот пример такого <code class="literal">compat</code>
            модуля, взятого из <code class="literal">python-gmaps</code>проекта ( <a class="ulink" href="https://github.com/swistakm/python-gmaps">https://github.com/swistakm/python-gmaps</a> ):
        </p>
<div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
import sys

if sys.version_info &lt; (3, 0, 0):
    import urlparse  # noqa

    def is_string(s):
        return isinstance(s, basestring)

else:
    from urllib import parse as urlparse  # noqa

    def is_string(s):
        return isinstance(s, str)</pre>
</div>
<p>Такой <code class="literal">compat.py</code>модуль популярен даже в проектах, которые зависят от совместимости Six for 2/3, потому что это очень удобный способ хранения кода, который обрабатывает совместимость с различными версиями пакетов, используемых в качестве зависимостей.</p>
<div class="note" style="" title="Примечание">
<div class="inner"><h3 class="title">Кончик</h3>
<p><span class="strong"><strong>Скачивание примера кода</strong></span></p>
<p>Вы можете загрузить файлы примеров кода для этой книги из своей учетной записи на <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> . Если вы приобрели эту книгу в другом месте, вы можете посетить <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> 
                    и зарегистрироваться, чтобы получать файлы по электронной почте непосредственно вам.</p>
<p>Вы можете скачать файлы кода, выполнив следующие действия:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">Войдите или зарегистрируйтесь на нашем веб-сайте, используя свой адрес электронной почты и пароль.
                        </li>
<li class="listitem" style="list-style-type: disc">Наведите указатель мыши на вкладку <span class="strong"><strong>ПОДДЕРЖКА</strong></span> вверху.
                        </li>
<li class="listitem" style="list-style-type: disc">Щелкните <span class="strong"><strong>Загрузка кода и исправления</strong></span> .
                        </li>
<li class="listitem" style="list-style-type: disc">Введите название книги в поле <span class="strong"><strong>поиска</strong></span> .
                        </li>
<li class="listitem" style="list-style-type: disc">Выберите книгу, для которой вы хотите загрузить файлы кода.
                        </li>
<li class="listitem" style="list-style-type: disc">В раскрывающемся меню выберите место, где вы купили эту книгу.
                        </li>
<li class="listitem" style="list-style-type: disc">Щелкните " <span class="strong"><strong>Загрузка кода"</strong></span> .
                        </li>
</ul>
</div>
<p>После загрузки файла убедитесь, что вы распаковали или извлекли папку, используя последнюю версию:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">WinRAR / 7-Zip для Windows</li>
<li class="listitem" style="list-style-type: disc">Zipeg / iZip / UnRarX для Mac</li>
<li class="listitem" style="list-style-type: disc">7-Zip / PeaZip для Linux</li>
</ul>
</div>
<p>Пакет кода для книги также размещен на GitHub по адресу <a class="ulink" href="https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition">https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition</a> . У нас также есть другие пакеты кода из нашего обширного каталога книг и видео, доступных по адресу <a class="ulink" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a> . Проверь их!</p></div>
</div>
</div>
</div>
</body></html>
