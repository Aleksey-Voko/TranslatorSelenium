<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Изоляция среды на системном уровне</title>
<link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
</head>
<body id="page">
<div class="section" title="Изоляция среды на системном уровне">
<div class="titlepage">
<div>
<div><h1 class="title">Изоляция среды на системном уровне</h1></div>
</div>
</div>
<p>В большинстве случаев реализация программного обеспечения может выполняться быстро, потому что разработчики повторно используют множество существующих компонентов. Не повторяйся - это популярное правило и девиз многих программистов. Использование других пакетов и модулей для включения их в кодовую базу - только часть этой культуры. Под «повторно используемыми компонентами» можно также отнести двоичные библиотеки, базы данных, системные службы, сторонние API и т. Д. Даже целые операционные системы следует рассматривать как повторно используемые.</p>
<p>Серверные службы веб-приложений - отличный пример того, насколько сложными могут быть такие приложения. Простейший программный стек обычно состоит из нескольких уровней (начиная с самого низкого):</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">База данных или другое хранилище</li>
<li class="listitem" style="list-style-type: disc">Код приложения, реализованный на Python</li>
<li class="listitem" style="list-style-type: disc">HTTP-сервер, такой как Apache или NGINX</li>
</ul>
</div>
<p>Конечно, такой стек может быть и проще, но это маловероятно. На самом деле, большие приложения часто настолько сложны, что трудно различить отдельные слои. Большие приложения могут использовать множество разных баз данных, быть разделенными на несколько независимых процессов и использовать множество других системных служб для кэширования, постановки в очередь, ведения журнала, обнаружения служб и т. Д. К сожалению, для сложности нет никаких ограничений, и кажется, что код просто следует второму закону термодинамики.</p>
<p>Что действительно важно, так это то, что не все элементы программного стека могут быть изолированы на уровне среды выполнения Python. Независимо от того, является ли это HTTP-сервером, таким как NGINX, или РСУБД, например PostgreSQL, они обычно доступны в разных версиях в разных системах. Без соответствующих инструментов очень сложно сделать так, чтобы все в команде разработчиков использовали одни и те же версии каждого компонента. Теоретически возможно, что все разработчики в команде, работающей над одним проектом, смогут получить одни и те же версии сервисов на своих модулях разработки. Но все эти усилия бесполезны, если они не используют ту же операционную систему, что и в производственной среде. И заставить программиста работать над чем-то другим, кроме его любимой системы, наверняка невозможно.</p>
<p>Проблема заключается в том, что переносимость по-прежнему остается большой проблемой. Не все службы будут работать в производственной среде точно так же, как на машинах разработчика, и это вряд ли изменится. Даже Python может вести себя по-разному в разных системах, несмотря на то, сколько работы было вложено, чтобы сделать его кроссплатформенным. Обычно это хорошо документировано и происходит только в тех местах, которые напрямую зависят от системных вызовов, но полагаться на способность программиста запомнить длинный список причуд совместимости - довольно рискованная стратегия.</p>
<p>Популярное решение этой проблемы - изолировать целые системы как среды приложений. Обычно это достигается за счет использования различных инструментов виртуализации системы. Виртуализация, конечно, снижает производительность, но на современных компьютерах с аппаратной поддержкой виртуализации потеря производительности обычно незначительна. С другой стороны, список возможных выгод очень длинный:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">Среда разработки может точно соответствовать версии системы и службам, используемым в производстве, что помогает в решении проблем совместимости.
            </li>
<li class="listitem" style="list-style-type: disc">Определения для инструментов конфигурации системы, таких как Puppet, Chef или Ansible (если используются), можно повторно использовать для настройки среды разработки.
            </li>
<li class="listitem" style="list-style-type: disc">Вновь нанятые члены команды могут легко перейти в проект, если создание таких сред автоматизировано.
            </li>
<li class="listitem" style="list-style-type: disc">Разработчики могут работать напрямую с функциями низкого системного уровня, которые могут быть недоступны в операционных системах, которые они используют для работы, например, <span class="strong"><strong>FUSE</strong></span> ( <span class="strong"><strong>файловая система в пространстве пользователя</strong></span> ), которая недоступна в Windows.
            </li>
</ul>
</div>
<div class="section" title="Виртуальные среды разработки с использованием Vagrant">
<div class="titlepage">
<div>
<div><h2 class="title">Виртуальные среды разработки с использованием Vagrant</h2></div>
</div>
</div>
<p>Vagrant в настоящее время кажется самым популярным инструментом, который обеспечивает простой и удобный способ создания сред разработки и управления ими. Он доступен для Windows, Mac OS и нескольких популярных дистрибутивов Linux (см. <a class="ulink" href="https://www.vagrantup.com">Https://www.vagrantup.com</a> ). Никаких дополнительных зависимостей не имеет. Vagrant создает новые среды разработки в виде виртуальных машин или контейнеров. Точная реализация зависит от выбора провайдеров виртуализации. VirtualBox является поставщиком по умолчанию, и он входит в комплект установщика Vagrant, но также доступны дополнительные поставщики. Наиболее заметными вариантами являются VMware, Docker, LXC (контейнеры Linux) и Hyper-V.</p>
<p>Наиболее важная конфигурация предоставляется Vagrant в одном файле с именем <code class="literal">Vagrantfile</code>. Он должен быть независимым для каждого проекта. Вот самые важные вещи, которые он предоставляет:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem" style="list-style-type: disc">Выбор провайдера виртуализации</li>
<li class="listitem" style="list-style-type: disc">Коробка, используемая как образ виртуальной машины</li>
<li class="listitem" style="list-style-type: disc">Выбор метода предоставления</li>
<li class="listitem" style="list-style-type: disc">Общее хранилище между виртуальной машиной и ее хостом</li>
<li class="listitem" style="list-style-type: disc">Порты, которые необходимо перенаправить между виртуальной машиной и ее хостом
                </li>
</ul>
</div>
<p>Язык синтаксиса для <code class="literal">Vagrantfile</code>- Ruby. Пример файла конфигурации представляет собой хороший шаблон для запуска проекта и отличную документацию, поэтому знание этого языка не требуется. Конфигурацию шаблона можно создать с помощью одной команды:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>vagrant init</strong></span>
</pre>
</div>
<p>Это создаст новый файл с именем <code class="literal">Vagrantfile</code>в текущем рабочем каталоге. Лучшее место для хранения этого файла - это обычно корень связанных исходных кодов проекта. Этот файл уже является допустимой конфигурацией, которая создаст новую виртуальную машину с использованием поставщика по умолчанию и базового образа. По умолчанию подготовка не включена. После добавления <code class="literal">Vagrantfile</code>новая виртуальная машина запускается с использованием:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>vagrant up</strong></span>
</pre>
</div>
<p>Первоначальный запуск может занять несколько минут, потому что сам ящик должен быть загружен из Интернета. Существует также некоторый процесс инициализации, который может занять некоторое время в зависимости от используемого поставщика, устройства и производительности системы каждый раз, когда запускается уже существующая виртуальная машина. Обычно это занимает всего пару секунд. После того, как новая среда Vagrant будет запущена и запущена, разработчики могут подключаться к SSH, используя это сокращение:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>vagrant ssh</strong></span>
</pre>
</div>
<p>Это можно сделать в любом месте дерева исходных кодов проекта ниже расположения <code class="literal">Vagrantfile</code>. Для удобства разработчиков мы посмотрим в каталогах выше файл конфигурации и сопоставим его с соответствующим экземпляром виртуальной машины. Затем он устанавливает безопасное соединение с оболочкой, поэтому со средой разработки можно взаимодействовать, как с любой обычной удаленной машиной. Единственное отличие состоит в том, что все дерево исходных кодов проекта (корень определяется как расположение <code class="literal">Vagrantfile</code>) доступно в файловой системе виртуальной машины в папке <code class="literal">/vagrant/</code>.</p></div>
<div class="section" title="Контейнеризация против виртуализации">
<div class="titlepage">
<div>
<div><h2 class="title">Контейнеризация против виртуализации</h2></div>
</div>
</div>
<p>Контейнеры - альтернатива полной виртуализации машин. Это легкий метод виртуализации, при котором ядро ​​и операционная система позволяют запускать несколько изолированных экземпляров пользовательского пространства. ОС разделяется между контейнерами и хостом, поэтому теоретически требует меньше накладных расходов, чем при полной виртуализации. Такой контейнер содержит только код приложения и его зависимости на системном уровне, но с точки зрения процессов, выполняющихся внутри, он выглядит как полностью изолированная системная среда.</p>
<p>Программные контейнеры получили свою популярность во многом благодаря Docker; это одна из доступных реализаций. Docker позволяет описать свой контейнер в виде простого текстового документа с именем <code class="literal">Dockerfile</code>. Контейнеры из таких определений можно создавать и хранить. Он также поддерживает инкрементные изменения, поэтому, если в контейнер добавляются новые вещи, его не нужно воссоздавать с нуля.</p>
<p>Похоже, что разные инструменты, такие как Docker и Vagrant, частично совпадают по функциям, но основное различие между ними - причина, по которой эти инструменты были созданы. Vagrant, как упоминалось ранее, создан в первую очередь как инструмент для разработки. Он позволяет загружать всю виртуальную машину с помощью одной команды, но не позволяет просто упаковать ее и развернуть или выпустить как есть. Docker, с другой стороны, создан именно для этого - готовит полные контейнеры, которые можно отправлять и развертывать в производственной среде как единый пакет. При правильной реализации это может значительно улучшить процесс развертывания продукта. Из-за этого использование Docker и подобных решений (например, Rocket) во время разработки имеет смысл только в том случае, если его также необходимо использовать в процессе развертывания в производственной среде.</p></div>
</div>
</body></html>
